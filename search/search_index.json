{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LLMCode","text":"<p> LLMCode is a tool designed to streamline code documentation using Language Models (LLMs). </p> <p>  It is a user-friendly utility that harnesses the capabilities of Language Models to automatically generate code documentation. Say goodbye to the time-consuming and often tedious task of writing documentation by hand. With this tool, you can effortlessly self-updating code documentation, and then just review the work of LLMCode.  </p>"},{"location":"#features","title":"\ud83d\udccb Features","text":"<ul> <li> <p>\u2705 Seamless Integraton: LLMCode is a Python package installable via pip, compatible with various code editors, and seamlessly integrates with Git version control system.</p> </li> <li> <p>\u2705 Customizaton: Tailor the generated documentation to your needs by creating custom prompts. You can define the documentation format, with separate prompts for functions and classes.</p> </li> <li> <p>\u2705 Python support: LLMCode fully supports Python, allowing you to generate docstrings for functions and classes within your Python scripts. Document your entire project, specific scripts, or selected functions, and decide whether or not to overwrite existing documentation. All this can be achieved with straightforward CLI commands or by utilizing the Python library. Check out the USAGE section for more details.</p> </li> <li> <p>\u2705 GPT models: LLMCode currently supports GPT models, leveraging the OpenAI API for prompt-based completions. However, for users interested in interacting with other Language Models (LLMs), it's easy to create a custom 'get_completion' method. Detailed instructions can be found in the CUSTOM COMPLETIONS section.</p> </li> </ul>"},{"location":"#documentation","title":"\ud83d\udcda Documentation","text":"<p>The LLMCode documentation can be found here.</p> <p>You can also serve it locally with:</p> <pre><code>pip install mkdocs mkdocstrings[python] mkdocs-autorefs mkdocs-material mkdocs-gen-files\ncd path/to/LLMCode\nmkdocs serve\n</code></pre> <p>Open your browser and go to <code>http://127.0.0.1:8000/</code> to view the documentation.</p>"},{"location":"#contact","title":"\ud83d\udcec Contact","text":"<p>Francisco Javier Ga\u00f1\u00e1n - fjganan14@gmail.com</p>"},{"location":"customization/","title":"\ud83d\udee0 Customization","text":"<p>In addition to the CLI and Python-supported options, you can further customize LLMCode by editing the <code>path/to/this/repo/LLMCode/cfg/custom_params.py</code> script. Here, you can fine-tune various parameters to suit your specific needs. Further, you can easily customize LLMCode in two ways: creating your custom completion functions and creating your custom prompts.</p>"},{"location":"customization/#custom-completions","title":"Custom Completions","text":"<p>You have the flexibility to create your custom completion functions, even with your own LLMs. To integrate your custom completion function, follow these two steps:</p> <ol> <li>Define your <code>get_completion</code> function. You should do so in the <code>path/to/this/repo/LLMCode/utils/completion.py</code> file. Here's an example of how the <code>get_completion_openai</code> function is defined:</li> </ol> <pre><code>import openai\nimport LLMCode.cfg.completion_params as completion_params\n\ndef get_completion_openai(prompt):\n    params = {\n        key: value\n        for key, value in vars(completion_params).items()\n        if not key.startswith(\"__\")\n    }\n    return openai.ChatCompletion.create(\n        messages=[{\"role\": \"user\", \"content\": prompt}], **params\n    ).choices[0].message.content\n</code></pre> <p>Ensure that the function you define takes only a prompt (str) as input and outputs a response (str). The remaining parameters required for the function must be defined in <code>path/to/this/repo/LLMCode/cfg/completion_params.py</code> and loaded in the <code>completion.py</code> script, similar to how it's done for the 'get_completion_openai' function. For naming your function, it's recommended to follow the <code>get_completion_XXX</code> naming convention. If the function is capable of generating any exceptions, they should be included in the return statement. This is crucial to ensure that the upstream functions handle the exceptions appropriately.</p> <ol> <li>Configure the 'get_completion' function you want to use in the <code>path/to/this/repo/LLMCode/cfg/completion_params.py</code> script.</li> </ol> <p><code>python    completion_function = \"YOUR_COMPLETION_FUNCTION\"</code></p> <p>If you have a 'get_completion_XXX' function that you believe could benefit others, please consider contributing.</p>"},{"location":"customization/#custom-prompts","title":"Custom Prompts","text":"<p>You can write your own prompts to customize the documentation process. To do so, follow these steps:</p> <ol> <li>It is recommended to define them in the <code>path/to/this/repo/LLMCode/prompts/YOUR_USED_PROGRAMMING_LANGUAGE</code> folder. These prompts should be saved as .txt files. For example, Python prompts can be defined in the <code>path/to/this/repo/LLMCode/prompts/python</code> folder, with separate prompts for functions and classes. Here's an example of the 'documentFunction.txt' prompt used for documenting Python functions in the Google format:</li> </ol> <pre><code>Please, provide the docstring for the following FUNCTION in the following DOCSTRING FORMAT (that is the Google format for Python docstrings). If the FUNCTION already has a docstring, check that it is correct and change what do you think it is convenient.\nIf the DOCSTRING FORMAT is not the provided one, change the format of the docstring.\n\nFUNCTION:\n    !&lt;QUERY COMPLETION&gt;!\n\nDOCSTRING FORMAT:\n    \"\"\"\n    Summary of the function.\n\n    More extensive description that allows for its complete understanding.\n\n    Args:\n        param1 (type1 | type2): Description of param1.\n        param2 (type, optional): Description of param2.\n        param3 (type): Description of param3 (default is default_paramerer_value).\n        ...\n\n    Returns:\n        type: Description of the return param.\n    \"\"\"\n\nI want you to generate as output only the docstring (in the specified format) and between triple quotes, without more text.\nThe output is intended to be copied directly to a code script.\n\n</code></pre> <p>Make sure to include the !\\&lt;QUERY COMPLETION&gt;! placeholder where you want your element (function or class) to be located, as LLMCode will replace it.</p> <ol> <li>Specify the paths of your custom prompts in the <code>path/to/this/repo/LLMCode/cfg/custom_params.py</code> file. If you have defined prompts in the <code>path/to/this/repo/LLMCode/prompts/YOUR_USED_PROGRAMMING_LANGUAGE</code> folder, update the configuration like this:</li> </ol> <pre><code>document_prompts = {  # Queries for the model to document function and classes\n    \"YOUR_USED_PROGRAMMING_LANGUAGE\": {\n        \"function\": Path(__file__).parent\n        / f\"..{os.path.sep}prompts{os.path.sep}YOUR_USED_PROGRAMMING_LANGUAGE{os.path.sep}YOUR_PROMPT_FOR_FUNTIONS.txt\",\n        \"class\": Path(__file__).parent\n        / f\"..{os.path.sep}prompts{os.path.sep}YOUR_USED_PROGRAMMING_LANGUAGE{os.path.sep}YOUR_PROMPT_FOR_CLASSES.txt\",\n    }\n}\n</code></pre> <p>If you discover prompts that work well with a specific LLM, please consider contributing.</p>"},{"location":"installation/","title":"\u2699\ufe0f Installation","text":"<p>To install LLMCode you can use pip.</p>"},{"location":"installation/#just-use-it","title":"Just use it","text":"<pre><code>pip install git+https://github.com/javierganan99/LLMCode.git\n</code></pre>"},{"location":"installation/#editable-mode-recommended","title":"Editable mode (recommended)","text":""},{"location":"installation/#clone-the-repository","title":"Clone the repository","text":"<pre><code>git clone https://github.com/javierganan99/LLMCode.git\ncd LLMCode\n</code></pre>"},{"location":"installation/#install-the-tool-using-pip","title":"Install the tool using pip","text":"<pre><code>pip install -e .\n</code></pre> <p>For developers to access the latest features and updates and for contributors.</p> <pre><code>git checkout develop\npip install -e .\n</code></pre>"},{"location":"usage/","title":"\ud83d\udda5\ufe0f Usage","text":"<p>LLMCode can be accessed through both the Command-Line Interface (CLI) and Python code. To use the GPT models supported and used by default you should have an OpenAI API Key that you can get here. To use other LLMs to get completions, create your own 'get_completion' function (see CUSTOM COMPLETIONS section).</p> <p>First, you need to export your API key:</p> <pre><code>export OPENAI_API_KEY=&lt;YOUR_API_KEY&gt;\n</code></pre>"},{"location":"usage/#cli","title":"CLI","text":"<p>To generate documentation for your code, use the following command:</p> <pre><code>docu &lt;path/to/your/code&gt; [--options]\n</code></pre> <p>Replace <code>path/to/your/code</code> with the path to your folder or script.</p> <p>The supported CLI options are:</p> <ul> <li> <p>--exclude (optional): Specify files or folders to exclude from documentation. If <code>path/to/your/code</code> is a directory, LLMCode will automatically exclude submodules in a git project. If not provided, only git submodules will be excluded.</p> </li> <li> <p>--languages (optional): Specify the programming languages used in your scripts for documentation. If <code>path/to/your/code</code> is a directory, LLMCode will document scripts in the detected language (if supported). Defaults to python.</p> </li> <li> <p>--elements2doc (optional): Specify the names of elements (functions and/or classes) you want to document. Other elements will not be documented. Defaults to None, which means documenting all elements.</p> </li> <li> <p>--overwrite (optional): Decide whether to overwrite existing documentation for elements. Defaults to False.</p> </li> </ul> <p>The <code>path/to/your/code</code> argument can be the path of a folder or a file. If it is a folder, LLMCode will find all scripts in the provided --languages (if supported) and document their elements. If it is a file, it will document all the elements in that file (or those specified in --elements2doc).</p> <p>By default, LLMCode will overwrite your code at its original location after completing the documentation process. It stores the files in a temporary directory while documenting them. If the process is canceled during execution, the documentation will be lost. If you want to save the documented code in a different location, please refer to the CUSTOMIZATON section for instructions.</p> <p>For example, you can document the LLMCode project with the following commands, excluding the scripts in the tests folder and the entrypoint.py script:</p> <pre><code>cd &lt;path/to/LLMCode&gt;\ndocu . --exclude tests entrypoint.py\n</code></pre>"},{"location":"usage/#python","title":"Python","text":"<p>LLMCode may also be used directly in a Python environment, and accepts the same arguments as in the CLI example above:</p> <pre><code>from LLMCode import docu\n\n# Document specified elements of your script\ndocu(path=\"path/to/your/script.py\", elements2doc=[\"your_function_name\", \"your_class_name\"], overwrite=True)\n\n# Document your project python scripts\ndocu(path=\"path/to/your/project\", languages=[\"python\"])\n</code></pre>"},{"location":"reference/entrypoint/","title":"Reference for <code>llmcode/entrypoint.py</code>","text":"<p>This module serves as the entry point for the LLMCode tool. It parses command-line arguments to determine the path to format, any directories or files to exclude, the programming languages to include, and the elements to document. It also handles the option to overwrite existing docstrings.</p> <p>Options:     path            The path to the script or folder to be documented.     --exclude       Exclude specific files or folders from the path.     --languages     Specify programming languages to include.     --elements2doc  Specify elements to document.     --overwrite     Overwrite existing docstrings if present.</p> <p>Author: Francisco Javier Ga\u00f1\u00e1n License File: https://github.com/javierganan99/LLMCode/blob/main/LICENSE</p> <p></p> <p></p> <p></p>"},{"location":"reference/entrypoint/#llmcode.entrypoint.parse_args","title":"llmcode.entrypoint.parse_args","text":"<pre><code>parse_args()\n</code></pre> <p>Parses command-line arguments for the script.</p> <p>This function sets up an argument parser to handle the input parameters required for the script execution. It allows the user to specify a path, exclude certain files or directories, choose programming languages, identify elements to document, and decide whether to overwrite existing docstrings.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to format without a name (default is None).</p> required <code>--exclude</code> <code>str</code> <p>A list of files or folders to exclude (default is exclude).</p> required <code>--languages</code> <code>str</code> <p>A list of programming languages to include (default is languages).</p> required <code>--elements2doc</code> <code>str</code> <p>A list of elements to document (default is elements2doc).</p> required <code>--overwrite</code> <code>bool</code> <p>Whether to overwrite the current docstrings (default is False).</p> required <p>Returns:</p> Name Type Description <code>Namespace</code> <p>An object containing the parsed arguments as attributes.</p> Source code in <code>llmcode/entrypoint.py</code> <pre><code>def parse_args():\n    \"\"\"\n    Parses command-line arguments for the script.\n\n    This function sets up an argument parser to handle the input parameters\n    required for the script execution. It allows the user to specify a path,\n    exclude certain files or directories, choose programming languages,\n    identify elements to document, and decide whether to overwrite existing\n    docstrings.\n\n    Args:\n        path (str, optional): The path to format without a name (default is None).\n        --exclude (str, optional): A list of files or folders to exclude (default is exclude).\n        --languages (str, optional): A list of programming languages to include (default is languages).\n        --elements2doc (str, optional): A list of elements to document (default is elements2doc).\n        --overwrite (bool, optional): Whether to overwrite the current docstrings (default is False).\n\n    Returns:\n        Namespace: An object containing the parsed arguments as attributes.\n    \"\"\"\n    parser = argparse.ArgumentParser(\n        description=\"The first param is the path to format but with no name. \\\n            You can add the --exclude param to exclude some dirs or files\"\n    )\n    parser.add_argument(\"path\", nargs=\"?\", default=None, help=\"Unnamed parameter\")\n    parser.add_argument(\n        \"--exclude\",\n        nargs=\"*\",\n        default=exclude,\n        help=\"Exclude some files or folders inside the path\",\n    )\n    parser.add_argument(\n        \"--languages\",\n        nargs=\"*\",\n        default=languages,\n        help=\"The programming languages you want to include\",\n    )\n    parser.add_argument(\n        \"--elements2doc\",\n        nargs=\"*\",\n        default=elements2doc,\n        help=\"The elements2doc names you want to document\",\n    )\n    parser.add_argument(\n        \"--overwrite\",\n        action=\"store_true\",\n        help=\"Wheter to overwrite or not the current docstrings\",\n    )\n    return parser.parse_args()\n</code></pre>"},{"location":"reference/entrypoint/#llmcode.entrypoint.main","title":"llmcode.entrypoint.main","text":"<pre><code>main()\n</code></pre> <p>Main function to initiate the formatting process for scripts or folders.</p> <p>This function sets up a signal handler for interrupt signals (SIGINT) to gracefully stop the operation when requested. It checks for the required path argument, and if missing, logs an informative message and exits. It then calls the <code>format_code</code> function with the appropriate parameters.</p> Source code in <code>llmcode/entrypoint.py</code> <pre><code>def main():\n    \"\"\"\n    Main function to initiate the formatting process for scripts or folders.\n\n    This function sets up a signal handler for interrupt signals (SIGINT) to gracefully stop the operation\n    when requested. It checks for the required path argument, and if missing, logs an informative message\n    and exits. It then calls the `format_code` function with the appropriate parameters.\n    \"\"\"\n\n    def crtl_c_handler(sig, frame):\n        stop_flag.set()\n\n    signal.signal(signal.SIGINT, crtl_c_handler)\n    stop_flag = Event()\n    args = parse_args()\n    if args.path is None:\n        LOGGER.info(\n            \"Missing path to format: Please provide the path to be documented. \\\n            It can be an script or a folder containing scripts at any level.\"\n        )\n        sys.exit(0)\n    format_code(\n        args.path,\n        args.exclude,\n        args.languages,\n        args.elements2doc,\n        args.overwrite,\n        stop_flag,\n    )\n</code></pre>"},{"location":"reference/utils/auxiliary/","title":"Reference for <code>llmcode/utils/auxiliary.py</code>","text":"<p>This module provides utilities for formatting and documenting code files.</p> <p>It includes functions to format code files, apply documentation functions based on programming languages, and manage temporary file operations during the documentation process.</p> <p>Functions:     format_code: Formats and documents code files in the specified path.     _apply_to_scripts: Applies a given function to scripts in a directory, handling temporary files.</p> <p>Author: Francisco Javier Ga\u00f1\u00e1n License File: https://github.com/javierganan99/LLMCode/blob/main/LICENSE</p> <p></p> <p></p> <p></p>"},{"location":"reference/utils/auxiliary/#llmcode.utils.auxiliary.format_code","title":"llmcode.utils.auxiliary.format_code","text":"<pre><code>format_code(path, exclude=custom_params.exclude, languages=custom_params.languages, elements2doc=custom_params.elements2doc, overwrite=custom_params.overwrite, stop_flag=Event())\n</code></pre> <p>Formats code files by applying specific documentation functions based on language.</p> <p>This function processes either a directory or a specific code file, excluding specified files from documentation generation, and applies predefined functions according to the code's language. It validates the input path, checks supported languages, and logs relevant information during the process. If the path is a directory, it applies the functions to all relevant scripts within.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the directory or file to be formatted.</p> required <code>exclude</code> <code>list</code> <p>List of filenames or folders to exclude from documentation (default is custom_params.exclude).</p> <code>exclude</code> <code>languages</code> <code>list</code> <p>List of programming languages to apply for documentation (default is custom_params.languages).</p> <code>languages</code> <code>elements2doc</code> <code>list</code> <p>List of specific elements to document (default is custom_params.elements2doc).</p> <code>elements2doc</code> <code>overwrite</code> <code>bool</code> <p>Flag indicating whether to overwrite existing documentation (default is custom_params.overwrite).</p> <code>overwrite</code> <code>stop_flag</code> <code>Event</code> <p>A threading event to signal when to stop the process (default is Event()).</p> <code>Event()</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the formatting process was successful, False otherwise.</p> Source code in <code>llmcode/utils/auxiliary.py</code> <pre><code>def format_code(\n    path,\n    exclude=custom_params.exclude,\n    languages=custom_params.languages,\n    elements2doc=custom_params.elements2doc,\n    overwrite=custom_params.overwrite,\n    stop_flag=Event(),\n):\n    \"\"\"\n    Formats code files by applying specific documentation functions based on language.\n\n    This function processes either a directory or a specific code file, excluding specified files\n    from documentation generation, and applies predefined functions according to the code's language.\n    It validates the input path, checks supported languages, and logs relevant information during the\n    process. If the path is a directory, it applies the functions to all relevant scripts within.\n\n    Args:\n        path (str): The path to the directory or file to be formatted.\n        exclude (list, optional): List of filenames or folders to exclude from documentation (default is custom_params.exclude).\n        languages (list, optional): List of programming languages to apply for documentation (default is custom_params.languages).\n        elements2doc (list, optional): List of specific elements to document (default is custom_params.elements2doc).\n        overwrite (bool, optional): Flag indicating whether to overwrite existing documentation (default is custom_params.overwrite).\n        stop_flag (Event, optional): A threading event to signal when to stop the process (default is Event()).\n\n    Returns:\n        (bool): True if the formatting process was successful, False otherwise.\n    \"\"\"\n    languages_filtered = languages.copy()\n    path = Path(path)\n    assert path.exists(), f\"{ANSI_CODE['red']}\\r\u274c {path} does not exist.\"\n    if path.is_dir():\n        for i, l in enumerate(languages):\n            if l not in DOC_FUNCTION.keys():\n                LOGGER.info(\n                    \"%s\\r\u26a0 Language %s not yet supported for docummentation. The %s scripts will not be docummented!\",\n                    ANSI_CODE[\"yellow\"],\n                    l,\n                    l,\n                )\n                languages_filtered.pop(i)\n        # Check if the exclude folders exist, if there is an error stop the program to warn the user\n        for e in exclude:\n            assert is_file_in_directory(\n                path, e\n            ), f\"{ANSI_CODE['red']}\\r\u274c Check the name of the file {e} that you want to exclude because it is not included in {path}, you could have make a typo!\"\n        exclude.extend(list_submodule_directories(path))\n        if exclude:\n            exc_str = \" \".join(exclude)\n            LOGGER.info(\n                \"%s\\r\u26a0 Excluding the following files from the document process: %s\",\n                ANSI_CODE[\"yellow\"],\n                exc_str,\n            )\n    elif path.is_file() and (\n        (path.suffix not in SUFFIX.values())\n        or LANGUAGE[path.suffix] not in DOC_FUNCTION.keys()\n    ):\n        LOGGER.info(\n            \"%s\\r\u274c The script %s can not be documented. Programming language with extension %s not supported.\",\n            ANSI_CODE[\"red\"],\n            str(path),\n            path.suffix,\n        )\n        return None\n    new_path = (\n        copy_path(path, add_to_parent=custom_params.surname)\n        if not custom_params.rewrite\n        else path\n    )\n    for l in languages_filtered:\n        if stop_flag.is_set():\n            break\n        _apply_to_scripts(\n            new_path,\n            (\n                DOC_FUNCTION[l][\"function\"]\n                if path.is_dir()\n                else DOC_FUNCTION[LANGUAGE[path.suffix]][\"function\"]\n            ),\n            extension=SUFFIX[l] if path.is_dir() else path.suffix,\n            exclude=exclude,\n            stop_flag=stop_flag,\n            get_completion=get_completion,\n            **{\n                **DOC_FUNCTION[l][\"kwargs\"],\n                \"elements2doc\": elements2doc,\n                \"overwrite\": overwrite,\n            },\n        )\n    return True\n</code></pre>"},{"location":"reference/utils/auxiliary/#llmcode.utils.auxiliary._apply_to_scripts","title":"llmcode.utils.auxiliary._apply_to_scripts","text":"<pre><code>_apply_to_scripts(root_path, function_to_execute, extension, exclude, stop_flag=Event(), *args, **kwargs)\n</code></pre> <p>Applies a specified function to all scripts in a given directory with a specified extension.</p> <p>This function searches the provided directory (and its subdirectories) for files that match the given extension. It allows for exclusion of specific files and applies a provided function to each of the found files, handling temporary file creation and cleanup.</p> <p>Parameters:</p> Name Type Description Default <code>root_path</code> <code>str</code> <p>The root directory path where the scripts are located.</p> required <code>function_to_execute</code> <code>callable</code> <p>The function to execute on each found script.</p> required <code>extension</code> <code>str</code> <p>The file extension of the scripts to process.</p> required <code>exclude</code> <code>list</code> <p>A list of substrings; files containing any of these will be excluded from processing.</p> required <code>stop_flag</code> <code>Event</code> <p>A flag to signal cessation of the function execution (default is Event()).</p> <code>Event()</code> <code>*args</code> <p>Additional positional arguments to be passed to the function.</p> <code>()</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the operation was successful, otherwise None.</p> Source code in <code>llmcode/utils/auxiliary.py</code> <pre><code>def _apply_to_scripts(\n    root_path,\n    function_to_execute,\n    extension,\n    exclude,\n    stop_flag=Event(),\n    *args,\n    **kwargs,\n):\n    \"\"\"\n    Applies a specified function to all scripts in a given directory with a specified extension.\n\n    This function searches the provided directory (and its subdirectories) for files that match the given\n    extension. It allows for exclusion of specific files and applies a provided function to each of the\n    found files, handling temporary file creation and cleanup.\n\n    Args:\n        root_path (str): The root directory path where the scripts are located.\n        function_to_execute (callable): The function to execute on each found script.\n        extension (str): The file extension of the scripts to process.\n        exclude (list): A list of substrings; files containing any of these will be excluded from processing.\n        stop_flag (Event, optional): A flag to signal cessation of the function execution (default is Event()).\n        *args: Additional positional arguments to be passed to the function.\n        **kwargs: Additional keyword arguments to be passed to the function.\n\n    Returns:\n        (bool): True if the operation was successful, otherwise None.\n    \"\"\"\n    root_path = Path(root_path).resolve()\n    if root_path.is_dir():\n        files = [py_file.resolve() for py_file in root_path.glob(f\"**/*{extension}\")]\n        if not files:\n            LOGGER.info(\n                \"%s\\r\u26a0 No scripts were found for %s in the folder %s\",\n                ANSI_CODE[\"yellow\"],\n                LANGUAGE[extension],\n                str(root_path),\n            )\n            return None\n        files = [\n            file\n            for file in files\n            if not any([str(discard) in str(file) for discard in exclude])\n        ]\n        # Create temporary project\n        temporary_files = []\n        temporary_folders = []\n        for file in files:\n            folder_name = str(file.parent).replace(\n                str(root_path), get_temp_folder() + os.path.sep + str(root_path.name)\n            )\n            ensure_folder_exist(folder_name)\n            temporary_folders.append(folder_name)\n            temporary_files.append(Path(folder_name) / file.name)\n        temporary_folders = list(set(temporary_folders))  # Get unique elements\n        # Copy the files to the temporary dir\n        for f, tf in zip(files, temporary_files):\n            shutil.copyfile(f, tf)\n        pbar = tqdm(\n            temporary_files,\n            desc=f\"{ANSI_CODE['reset']}\\rStarting to document...\",\n            total=len(temporary_files),\n            bar_format=TQDM_BAR_FORMAT,\n        )\n        for c_file in pbar:\n            pbar.set_description(\n                f\"{ANSI_CODE['reset']}\\rDocumenting script {c_file}...\"\n            )\n            function_to_execute(c_file, stop_flag=stop_flag, *args, **kwargs)\n            if stop_flag.is_set():\n                LOGGER.info(\n                    \"%s\\r Terminated by user. Program was documenting script %s\",\n                    ANSI_CODE[\"yellow\"],\n                    str(c_file),\n                )\n                break\n        pbar.close()\n        # Copy the files to the original location and delete the temporary file\n        for f, tf in zip(files, temporary_files):\n            shutil.copyfile(tf, f)\n            os.remove(tf)\n    else:\n        folder_name = str(root_path.parent).replace(\n            str(root_path.parent),\n            get_temp_folder() + os.path.sep + str(root_path.parent.name),\n        )\n        ensure_folder_exist(folder_name)\n        file = Path(folder_name) / root_path.name\n        shutil.copyfile(root_path, file)\n        function_to_execute(file, stop_flag=stop_flag, *args, **kwargs)\n        shutil.copyfile(file, root_path)\n        os.remove(file)\n    return True\n</code></pre>"},{"location":"reference/utils/completion/","title":"Reference for <code>llmcode/utils/completion.py</code>","text":"<p>This module handles the completion functionality using an LLM API.</p> <p>It provides functions to execute tasks with a timeout and to obtain completions from LLM APIs based on specified parameters.</p> <p>Functions:     run_with_timeout: Executes a function with a specified timeout.     get_completion_openai: Retrieves a completion from the OpenAI API using a prompt.</p> <p>Author: Francisco Javier Ga\u00f1\u00e1n License File: https://github.com/javierganan99/LLMCode/blob/main/LICENSE</p> <p></p> <p></p> <p></p>"},{"location":"reference/utils/completion/#llmcode.utils.completion.run_with_timeout","title":"llmcode.utils.completion.run_with_timeout","text":"<pre><code>run_with_timeout(target_function, args=(), kwargs={}, timeout=30)\n</code></pre> <p>Runs a target function with specified arguments and keyword arguments within a given timeout.</p> <p>This function uses a separate thread to execute the target_function with the provided args and kwargs. If the function completes within the timeout period, its result is returned. If it exceeds the timeout, or if an exception occurs during execution, the function will log an informative message and return None.</p> <p>Parameters:</p> Name Type Description Default <code>target_function</code> <code>callable</code> <p>The function to execute.</p> required <code>args</code> <code>tuple</code> <p>Positional arguments to pass to the target_function (default is empty tuple).</p> <code>()</code> <code>kwargs</code> <code>dict</code> <p>Keyword arguments to pass to the target_function (default is empty dictionary).</p> <code>{}</code> <code>timeout</code> <code>int</code> <p>The time in seconds to wait for the function execution before timing out (default is 30).</p> <code>30</code> <p>Returns:</p> Type Description <code>any | None</code> <p>The result of the target_function if it completes successfully; None if it times out or raises an exception.</p> Source code in <code>llmcode/utils/completion.py</code> <pre><code>def run_with_timeout(target_function, args=(), kwargs={}, timeout=30):\n    \"\"\"\n    Runs a target function with specified arguments and keyword arguments within a given timeout.\n\n    This function uses a separate thread to execute the target_function with the provided args and kwargs.\n    If the function completes within the timeout period, its result is returned. If it exceeds the timeout,\n    or if an exception occurs during execution, the function will log an informative message and return None.\n\n    Args:\n        target_function (callable): The function to execute.\n        args (tuple, optional): Positional arguments to pass to the target_function (default is empty tuple).\n        kwargs (dict, optional): Keyword arguments to pass to the target_function (default is empty dictionary).\n        timeout (int, optional): The time in seconds to wait for the function execution before timing out (default is 30).\n\n    Returns:\n        (any | None): The result of the target_function if it completes successfully; None if it times out or raises an exception.\n    \"\"\"\n    result = [None]  # A mutable container to store the function result\n    exception = [None]  # A container to capture exceptions\n\n    def target_wrapper():\n        try:\n            result[0] = target_function(*args, **kwargs)\n        except Exception as e:\n            exception[0] = e\n\n    thread = threading.Thread(target=target_wrapper)\n    thread.start()\n    thread.join(timeout)\n    if thread.is_alive():\n        LOGGER.info(\n            \"%s\u26a0 The completion could not be done. %s response lasted more than %s seconds, which is the limit.\",\n            ANSI_CODE[\"yellow\"],\n            target_function.__name__,\n            timeout,\n        )\n        return None\n    if exception[0]:\n        LOGGER.info(\n            \"%s\u26a0 The completion could not be done. %s raised the exception %s\",\n            ANSI_CODE[\"yellow\"],\n            target_function.__name__,\n            exception[0],\n        )\n        return None\n    return result[0]\n</code></pre>"},{"location":"reference/utils/completion/#llmcode.utils.completion.get_completion_openai","title":"llmcode.utils.completion.get_completion_openai","text":"<pre><code>get_completion_openai(prompt)\n</code></pre> <p>Generates a completion response from OpenAI's Chat API based on the provided prompt.</p> <p>This function takes a user-defined prompt and sends it to the OpenAI completion model, returning the content of the model's response. Additional parameters for the completion can be passed using the <code>completion_params</code> object, which is filtered to exclude any private attributes.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The input text that the model will generate a response for.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The content of the model's response.</p> Source code in <code>llmcode/utils/completion.py</code> <pre><code>def get_completion_openai(prompt):\n    \"\"\"\n    Generates a completion response from OpenAI's Chat API based on the provided prompt.\n\n    This function takes a user-defined prompt and sends it to the OpenAI completion model,\n    returning the content of the model's response. Additional parameters for the completion\n    can be passed using the `completion_params` object, which is filtered to exclude any\n    private attributes.\n\n    Args:\n        prompt (str): The input text that the model will generate a response for.\n\n    Returns:\n        (str): The content of the model's response.\n    \"\"\"\n    params = {\n        key: value\n        for key, value in vars(completion_params).items()\n        if not key.startswith(\"__\")\n    }\n    return (\n        openai.ChatCompletion.create(\n            messages=[{\"role\": \"user\", \"content\": prompt}], **params\n        )\n        .choices[0]\n        .message.content\n    )\n</code></pre>"},{"location":"reference/utils/document/","title":"Reference for <code>llmcode/utils/document.py</code>","text":"<p>This module provides functionality for documenting Python scripts.</p> <p>It includes functions to parse Python scripts, extract classes and functions, and generate or update docstrings using a completion model.</p> <p>Functions:     doc_element: Generates a docstring for a given element using a completion model.     doc_python_file: Documents a Python file by generating or updating docstrings for its elements.</p> <p>Author: Francisco Javier Ga\u00f1\u00e1n License File: https://github.com/javierganan99/LLMCode/blob/main/LICENSE</p> <p></p> <p></p> <p></p>"},{"location":"reference/utils/document/#llmcode.utils.document.doc_element","title":"llmcode.utils.document.doc_element","text":"<pre><code>doc_element(element, prompt, get_completion)\n</code></pre> <p>Processes a specific element by generating a completion based on a provided prompt.</p> <p>This function utilizes a completion generator, replaces a specific key in the prompt with the given element, and executes the generation process within a specified timeout limit.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>str</code> <p>The specific element to be processed and substituted in the prompt.</p> required <code>prompt</code> <code>str</code> <p>The prompt template that includes a placeholder for the element.</p> required <code>get_completion</code> <code>callable</code> <p>A function responsible for generating the completion based on the modified prompt.</p> required <p>Returns:</p> Type Description <code>any</code> <p>The result of the completion generation, which can vary depending on the</p> <p>implementation of the get_completion function.</p> Source code in <code>llmcode/utils/document.py</code> <pre><code>def doc_element(element, prompt, get_completion):\n    \"\"\"\n    Processes a specific element by generating a completion based on a provided prompt.\n\n    This function utilizes a completion generator, replaces a specific key in the prompt with\n    the given element, and executes the generation process within a specified timeout limit.\n\n    Args:\n        element (str): The specific element to be processed and substituted in the prompt.\n        prompt (str): The prompt template that includes a placeholder for the element.\n        get_completion (callable): A function responsible for generating the completion based\n            on the modified prompt.\n\n    Returns:\n        (any): The result of the completion generation, which can vary depending on the\n        implementation of the get_completion function.\n    \"\"\"\n    return run_with_timeout(\n        get_completion,\n        args=(\n            read_content(prompt).replace(custom_params.query_completion_key, element),\n        ),\n        timeout=custom_params.completion_timeout,\n    )\n</code></pre>"},{"location":"reference/utils/document/#llmcode.utils.document.doc_python_file","title":"llmcode.utils.document.doc_python_file","text":"<pre><code>doc_python_file(script, prompts, elements2doc=custom_params.elements2doc, overwrite=custom_params.overwrite, get_completion=get_completion, stop_flag=Event(), TODO_message='# TODO: Document this ELEMENT on your own. Could not be documented by the model.')\n</code></pre> <p>Documents Python files by generating docstrings for classes and functions.</p> <p>This function parses a given Python script, extracts the defined classes and functions, and generates docstrings for them using specified prompts and a completion function. It also handles existing docstrings based on the overwrite parameter and can stop the documentation process if triggered.</p> <p>Parameters:</p> Name Type Description Default <code>script</code> <code>str</code> <p>The path to the Python script file to be documented.</p> required <code>prompts</code> <code>dict</code> <p>A dictionary with the prompts to be used for generating docstrings.</p> required <code>elements2doc</code> <code>list</code> <p>A list of elements (classes or functions) to document. Defaults to custom_params.elements2doc.</p> <code>elements2doc</code> <code>overwrite</code> <code>bool</code> <p>Flag indicating whether to overwrite existing docstrings. Defaults to custom_params.overwrite.</p> <code>overwrite</code> <code>get_completion</code> <code>callable</code> <p>A function to get the completion responses. Defaults to get_completion.</p> <code>get_completion</code> <code>stop_flag</code> <code>Event</code> <p>An event flag to signal stopping the documentation process. Defaults to Event().</p> <code>Event()</code> <code>TODO_message</code> <code>str</code> <p>Message template to indicate that an element could not be documented. Defaults to \"# TODO: Document this ELEMENT on your own. Could not be documented by the model.\"</p> <code>'# TODO: Document this ELEMENT on your own. Could not be documented by the model.'</code> Source code in <code>llmcode/utils/document.py</code> <pre><code>def doc_python_file(\n    script,\n    prompts,\n    elements2doc=custom_params.elements2doc,\n    overwrite=custom_params.overwrite,\n    get_completion=get_completion,\n    stop_flag=Event(),\n    TODO_message=\"# TODO: Document this ELEMENT on your own. Could not be documented by the model.\",\n):\n    \"\"\"\n    Documents Python files by generating docstrings for classes and functions.\n\n    This function parses a given Python script, extracts the defined classes and functions, and generates docstrings\n    for them using specified prompts and a completion function. It also handles existing docstrings based on the\n    overwrite parameter and can stop the documentation process if triggered.\n\n    Args:\n        script (str): The path to the Python script file to be documented.\n        prompts (dict): A dictionary with the prompts to be used for generating docstrings.\n        elements2doc (list, optional): A list of elements (classes or functions) to document. Defaults to\n            custom_params.elements2doc.\n        overwrite (bool, optional): Flag indicating whether to overwrite existing docstrings. Defaults to\n            custom_params.overwrite.\n        get_completion (callable, optional): A function to get the completion responses. Defaults to get_completion.\n        stop_flag (Event, optional): An event flag to signal stopping the documentation process. Defaults to\n            Event().\n        TODO_message (str, optional): Message template to indicate that an element could not be documented.\n            Defaults to \"# TODO: Document this ELEMENT on your own. Could not be documented by the model.\"\n    \"\"\"\n    script = str(script)\n    try:\n        parsed = parse_python(script)\n        if parsed is None:\n            LOGGER.info(\n                \"%s\\r\u274cCheck the script {script}. It is not properly coded and can not be documented.\",\n                ANSI_CODE[\"red\"],\n            )\n            return None\n        (\n            classes_and_functions,\n            script_content,\n        ) = extract_functions_and_classes_from_python_tokens(parsed)\n    except Exception as e:\n        LOGGER.info(\n            \"%s\\r\u274cCheck the script %s. The following error occurred: %s\",\n            ANSI_CODE[\"red\"],\n            script,\n            e,\n        )\n\n    def add_msg(msg, where, element, script_content):\n        n_spaces = 0\n        for ch in element[where - 1 :: -1]:\n            if ch == \" \":\n                n_spaces += 1\n            else:\n                break\n        new_element = element[:where] + msg + \"\\n\" + \" \" * n_spaces + element[where:]\n        return script_content.replace(element, new_element)\n\n    for e_type, elements in classes_and_functions.items():\n        for element, e_name, dosctring_idx in elements:\n            if (\n                elements2doc is not None and e_name not in elements2doc\n            ):  # Filter the elements to document\n                continue\n            if stop_flag.is_set():\n                LOGGER.info(\n                    \"%s\\r Ended during the documentation of script %s. Interrupted by SIGINT.%s\",\n                    ANSI_CODE[\"yellow\"],\n                    script,\n                    ANSI_CODE[\"reset\"],\n                )\n                return\n            if e_type == \"function\" or e_type == \"class\":\n                if element[dosctring_idx : dosctring_idx + 3] == '\"\"\"':\n                    previous_docstring = re.search(r'\"\"\"(.*?)\"\"\"', element, re.DOTALL)\n                    if (\n                        previous_docstring and not overwrite\n                    ):  # If element had docstring and we do not want to change it\n                        continue\n                    LOGGER.info(\n                        \"%s\\r\\n\ud83e\udd16 Generating docstring for %s %s...\\n\\n\",\n                        ANSI_CODE[\"reset\"],\n                        e_type,\n                        e_name,\n                    )\n                else:\n                    previous_docstring = None\n                result = doc_element(element, prompts[e_type], get_completion)\n                if result is not None:  # Query successfull\n                    new_docstring = re.search(r'\"\"\"(.*?)\"\"\"', result, re.DOTALL)\n                    if new_docstring:\n                        new_docstring = new_docstring.group(1)\n                        LOGGER.info(\"%s\\r%s\\n\\n\\n\", ANSI_CODE[\"reset\"], new_docstring)\n                    else:\n                        LOGGER.info(\n                            \"%s\\r\u26a0 No docstring generated for %s %s...\",\n                            ANSI_CODE[\"yellow\"],\n                            e_type,\n                            e_name,\n                        )\n                        script_content = add_msg(\n                            TODO_message.replace(\"ELEMENT\", e_type),\n                            dosctring_idx,\n                            element,\n                            script_content,\n                        )\n                        continue\n                    if previous_docstring:  # If element had docstring\n                        previous_docstring = previous_docstring.group(1)\n                        element_new = element.replace(\n                            previous_docstring, new_docstring, 1\n                        )\n                        script_content = script_content.replace(element, element_new, 1)\n                    else:  # If element did not have docstring\n                        script_content = add_msg(\n                            f'\"\"\"{new_docstring}\"\"\"',\n                            dosctring_idx,\n                            element,\n                            script_content,\n                        )\n                else:  # Error in the query\n                    LOGGER.info(\n                        \"%s\\r\u274c Error in the query for %s %s! No response provided...\",\n                        ANSI_CODE[\"red\"],\n                        e_type,\n                        e_name,\n                    )\n                    script_content = add_msg(\n                        TODO_message.replace(\"ELEMENT\", e_type),\n                        dosctring_idx,\n                        element,\n                        script_content,\n                    )\n    with open(script, \"w\", encoding=\"utf-8\") as python_file:\n        python_file.write(script_content)\n</code></pre>"},{"location":"reference/utils/file_utils/","title":"Reference for <code>llmcode/utils/file_utils.py</code>","text":"<p>This module provides utility functions for file operations and code parsing.</p> <p>It includes functions to parse Python scripts, extract functions and classes, manage file and directory operations, and handle git submodules.</p> <p>Functions:     parse_python: Parses a Python file and returns its tokens.     extract_functions_and_classes_from_python_tokens: Extracts functions and         classes from Python tokens.     read_content: Reads the content of a file.     list_submodule_directories: Lists git submodule directories in a project.     is_file_in_directory: Checks if a file or directory exists within a given directory.     copy_path: Copies a file or directory to a new location with a modified name.     ensure_folder_exist: Ensures that a folder exists, creating it if necessary.     get_temp_folder: Returns the path to the system's temporary folder.</p> <p>Author: Francisco Javier Ga\u00f1\u00e1n License File: https://github.com/javierganan99/LLMCode/blob/main/LICENSE</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/utils/file_utils/#llmcode.utils.file_utils.parse_python","title":"llmcode.utils.file_utils.parse_python","text":"<pre><code>parse_python(fn)\n</code></pre> <p>Parses a Python script and returns its tokens.</p> <p>This function opens a Python script file, reads its content, and tokenizes it using the tokenize module. It checks for any errors in the script and raises an exception if any error tokens are found. The function ensures that the file is closed properly after reading.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>str</code> <p>The path to the Python script file to be parsed.</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of tokens parsed from the script.</p> Source code in <code>llmcode/utils/file_utils.py</code> <pre><code>def parse_python(fn):\n    \"\"\"\n    Parses a Python script and returns its tokens.\n\n    This function opens a Python script file, reads its content, and tokenizes it using\n    the tokenize module. It checks for any errors in the script and raises an exception\n    if any error tokens are found. The function ensures that the file is closed properly\n    after reading.\n\n    Args:\n        fn (str): The path to the Python script file to be parsed.\n\n    Returns:\n        (list): A list of tokens parsed from the script.\n    \"\"\"\n    fp = open(fn, mode=\"rb\")\n    try:\n        toks = list(tokenize(fp.readline))\n        for tok in toks:\n            if tok_name[tok.type] == \"ERRORTOKEN\":\n                raise ValueError(\n                    f\"{ANSI_CODE['red']}\\r\u274c Check the script {fn}. It contains errors.\"\n                )\n    except Exception as e:\n        raise ValueError(\"Script could not be tokenized\") from e\n    finally:\n        fp.close()\n    toks.pop(0)\n    return toks\n</code></pre>"},{"location":"reference/utils/file_utils/#llmcode.utils.file_utils.extract_functions_and_classes_from_python_tokens","title":"llmcode.utils.file_utils.extract_functions_and_classes_from_python_tokens","text":"<pre><code>extract_functions_and_classes_from_python_tokens(tokens)\n</code></pre> <p>Extract functions and classes from tokenized Python code.</p> <p>This function processes a list of tokens representing a Python script and extracts the definitions of functions and classes along with their associated docstrings. It handles indentation levels to accurately determine the boundaries of each extracted element.</p> <p>Parameters:</p> Name Type Description Default <code>tokens</code> <code>list of tuple</code> <p>A list of tokenized elements, where each element is a                     tuple containing the token type and additional                     information.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing two elements: - (dict): A dictionary with keys \"class\" and \"function\", each mapping to a           list of tuples containing the source code of the functions or           classes and their names, as well as the position of their           docstrings. - (str): The reconstructed Python code as a string.</p> Source code in <code>llmcode/utils/file_utils.py</code> <pre><code>def extract_functions_and_classes_from_python_tokens(tokens):\n    \"\"\"\n    Extract functions and classes from tokenized Python code.\n\n    This function processes a list of tokens representing a Python script and extracts\n    the definitions of functions and classes along with their associated docstrings.\n    It handles indentation levels to accurately determine the boundaries of each\n    extracted element.\n\n    Args:\n        tokens (list of tuple): A list of tokenized elements, where each element is a\n                                tuple containing the token type and additional\n                                information.\n\n    Returns:\n        (tuple): A tuple containing two elements:\n            - (dict): A dictionary with keys \"class\" and \"function\", each mapping to a\n                      list of tuples containing the source code of the functions or\n                      classes and their names, as well as the position of their\n                      docstrings.\n            - (str): The reconstructed Python code as a string.\n    \"\"\"\n    python_code = \"\"  # To store the code of the original Python file\n    current_row = 0\n    current_column = 0\n    current_idx = {\"class\": \"\", \"function\": \"\"}\n    stored = {\"class\": [], \"function\": []}\n    reading = {\"class\": False, \"function\": False}\n    indents = {\"class\": 0, \"function\": 0}\n    dedents = {\"class\": 0, \"function\": 0}\n    docstring_pos = {\"class\": None, \"function\": None}\n    name = {\"class\": None, \"function\": None}\n    prev_token = None\n    # Read the tokenized script from the input file\n    for token_line in tokens:\n        tt, ts, rc0, rc1, _ = token_line\n        ttn = tok_name[tt].lower()\n        start_row, end_row, start_col, end_col, token_type, token = (\n            int(rc0[0]),\n            int(rc1[0]),\n            int(rc0[1]),\n            int(rc1[1]),\n            ttn,\n            ts,\n        )\n        if token_type in [\"newline\", \"nl\"]:\n            token = \"\\n\"\n        elif token_type == \"indent\":\n            col_diff = end_col - start_col\n            token = \" \" * col_diff\n            for k, v in reading.items():\n                if v:\n                    if indents[k] == 0 and dedents[k] == 0:\n                        docstring_pos[k] = len(python_code) + col_diff - current_idx[k]\n                    indents[k] += 1\n        elif token_type == \"dedent\":\n            for k, v in reading.items():\n                if v:\n                    dedents[k] += 1\n        # Reset the column idx\n        if current_row &lt; start_row:\n            current_column = 0\n        # Ensure the current column matches the token's starting column\n        while current_column &lt; start_col:\n            python_code += \" \"  # Add spaces for missing columns\n            current_column += 1\n        if token_type == \"name\" and token == \"def\" and not reading[\"function\"]:\n            current_idx[\"function\"] = len(python_code)\n            reading[\"function\"] = True\n        elif token_type == \"name\" and token == \"class\" and not reading[\"class\"]:\n            current_idx[\"class\"] = len(python_code)\n            reading[\"class\"] = True\n        # Save the name of the element\n        if prev_token == \"def\" and name[\"function\"] == None:\n            name[\"function\"] = token\n        if prev_token == \"class\" and name[\"class\"] == None:\n            name[\"class\"] = token\n        # Append the token to the current code\n        python_code += token\n        # Check if finalised function or class\n        for k, v in reading.items():\n            if v and indents[k] == dedents[k] and indents[k] != 0:\n                # Append new element\n                stored[k].append(\n                    (python_code[current_idx[k] :], name[k], docstring_pos[k])\n                )\n                # Reset params\n                indents[k] = 0\n                dedents[k] = 0\n                reading[k] = False\n                docstring_pos[k] = None\n                name[k] = None\n        # Update the current row and column\n        current_row = end_row\n        current_column = end_col\n        # Save the previous token\n        prev_token = token\n    return stored, python_code\n</code></pre>"},{"location":"reference/utils/file_utils/#llmcode.utils.file_utils.read_content","title":"llmcode.utils.file_utils.read_content","text":"<pre><code>read_content(file_path)\n</code></pre> <p>Reads the content of a text file.</p> <p>This function opens a specified file in read mode and returns its entire content as a string. It is important to ensure that the file exists and is accessible to avoid exceptions.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the file to be read.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The content of the file as a string.</p> Source code in <code>llmcode/utils/file_utils.py</code> <pre><code>def read_content(file_path):\n    \"\"\"\n    Reads the content of a text file.\n\n    This function opens a specified file in read mode and returns its entire content as a string.\n    It is important to ensure that the file exists and is accessible to avoid exceptions.\n\n    Args:\n        file_path (str): The path to the file to be read.\n\n    Returns:\n        (str): The content of the file as a string.\n    \"\"\"\n    with open(file_path, \"r\") as file:\n        return file.read()\n</code></pre>"},{"location":"reference/utils/file_utils/#llmcode.utils.file_utils.list_submodule_directories","title":"llmcode.utils.file_utils.list_submodule_directories","text":"<pre><code>list_submodule_directories(project_directory)\n</code></pre> <p>Retrieves a list of submodule directory names from a specified Git project.</p> <p>This function executes the \"git submodule status\" command to fetch the status of submodules in a Git repository located at the specified project directory. It then processes the output to extract the names of the subdirectories that contain these submodules.</p> <p>Parameters:</p> Name Type Description Default <code>project_directory</code> <code>str</code> <p>The path to the Git project directory where</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of submodule directory names. If no submodules are found, an empty list is returned.</p> Source code in <code>llmcode/utils/file_utils.py</code> <pre><code>def list_submodule_directories(project_directory):\n    \"\"\"\n    Retrieves a list of submodule directory names from a specified Git project.\n\n    This function executes the \"git submodule status\" command to fetch the status\n    of submodules in a Git repository located at the specified project directory.\n    It then processes the output to extract the names of the subdirectories that\n    contain these submodules.\n\n    Args:\n        project_directory (str): The path to the Git project directory where\n        submodules are to be checked.\n\n    Returns:\n        (list): A list of submodule directory names. If no submodules are found, an\n            empty list is returned.\n    \"\"\"\n    project_directory = Path(project_directory)\n    submodule_directories = []\n    try:\n        # Use the \"git submodule status\" command to list submodules\n        git_command = [\"git\", \"submodule\", \"status\"]\n        result = subprocess.run(\n            git_command,\n            cwd=project_directory,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            text=True,\n            check=True,\n        )\n        # Split the output into lines and extract submodule directory names\n        output_lines = result.stdout.strip().split(\"\\n\")\n        for line in output_lines:\n            try:\n                _, submodule_path, _ = line.split()\n            except ValueError:  # TODO: Check error type\n                LOGGER.info(\n                    \"%s\\rNo git submodules found in the project\", ANSI_CODE[\"reset\"]\n                )\n                return submodule_directories\n            submodule_name = Path(submodule_path).name\n            submodule_directories.append(submodule_name)\n    except subprocess.CalledProcessError:\n        LOGGER.info(\"%s\\rNo git submodules found in the project\", ANSI_CODE[\"reset\"])\n    return submodule_directories\n</code></pre>"},{"location":"reference/utils/file_utils/#llmcode.utils.file_utils.is_file_in_directory","title":"llmcode.utils.file_utils.is_file_in_directory","text":"<pre><code>is_file_in_directory(directory, name)\n</code></pre> <p>Checks if a file or directory with a specified name exists within a given directory.</p> <p>This function traverses the specified directory and all its subdirectories to search for a file or directory that matches the provided name. It returns True if a match is found, otherwise it returns False.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str or Path</code> <p>The path to the directory to search in.</p> required <code>name</code> <code>str</code> <p>The name of the file or directory to look for.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the file or directory exists in the directory, False otherwise.</p> Source code in <code>llmcode/utils/file_utils.py</code> <pre><code>def is_file_in_directory(directory, name):\n    \"\"\"\n    Checks if a file or directory with a specified name exists within a given directory.\n\n    This function traverses the specified directory and all its subdirectories to search\n    for a file or directory that matches the provided name. It returns True if a match is found,\n    otherwise it returns False.\n\n    Args:\n        directory (str or Path): The path to the directory to search in.\n        name (str): The name of the file or directory to look for.\n\n    Returns:\n        (bool): True if the file or directory exists in the directory, False otherwise.\n    \"\"\"\n    directory = Path(directory)\n    for item in directory.glob(\"**/*\"):\n        if item.is_dir() and item.name == name:\n            return True\n        elif item.is_file() and item.name == name:\n            return True\n    return False\n</code></pre>"},{"location":"reference/utils/file_utils/#llmcode.utils.file_utils.copy_path","title":"llmcode.utils.file_utils.copy_path","text":"<pre><code>copy_path(path, add_to_parent='_formatted')\n</code></pre> <p>Copies a file or directory to a new formatted path and creates a documented version if applicable.</p> <p>This function checks if the specified path exists and determines if it is a file or directory. If it is a file with a supported suffix, it copies the file to a new location, appending a specified string to the base filename. If the path points to a directory, it copies the directory and maintains the new formatted name. Error messages are logged for non-existent paths, files that cannot be documented, and existing paths.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str or Path</code> <p>The path of the file or directory to copy.</p> required <code>add_to_parent</code> <code>str</code> <p>The string to append to the base name for the formatted file or directory (default is '_formatted').</p> <code>'_formatted'</code> <p>Returns:</p> Type Description <code>Path</code> <p>The path of the newly created formatted file or directory.</p> Source code in <code>llmcode/utils/file_utils.py</code> <pre><code>def copy_path(path, add_to_parent=\"_formatted\"):\n    \"\"\"\n    Copies a file or directory to a new formatted path and creates a documented version if applicable.\n\n    This function checks if the specified path exists and determines if it is a file or directory.\n    If it is a file with a supported suffix, it copies the file to a new location, appending a\n    specified string to the base filename. If the path points to a directory, it copies the\n    directory and maintains the new formatted name. Error messages are logged for non-existent\n    paths, files that cannot be documented, and existing paths.\n\n    Args:\n        path (str or Path): The path of the file or directory to copy.\n        add_to_parent (str, optional): The string to append to the base name for the formatted file\n            or directory (default is '_formatted').\n\n    Returns:\n        (Path): The path of the newly created formatted file or directory.\n    \"\"\"\n    path = Path(path).resolve()\n    if not path.exists():\n        raise FileNotFoundError(\n            f\"{ANSI_CODE['red']}\\r\u274cError: '{path}' does not exist.\"\n        )\n    formatted_base_name = f\"{path.stem}{add_to_parent}{path.suffix}\"\n    formatted_path = path.parent / formatted_base_name\n    if path.is_file() and path.suffix in SUFFIX.values():\n        try:\n            shutil.copy(path, formatted_path)\n            LOGGER.info(\n                \"%s\\rFile %s copied and documented version is to be created: %s\",\n                ANSI_CODE[\"reset\"],\n                path.name,\n                formatted_base_name,\n            )\n        except FileExistsError:\n            LOGGER.info(\"%s\\r\u26a0 The file {path} already exists.\", ANSI_CODE[\"yellow\"])\n    elif path.is_file() and path.suffix not in SUFFIX.values():\n        LOGGER.info(\n            \"%s\\r\u274c The script {path} can not be documented. Programming language not supported yet.\",\n            ANSI_CODE[\"red\"],\n        )\n        return None\n    elif path.is_dir():\n        try:\n            shutil.copytree(path, formatted_path)\n            LOGGER.info(\n                \"%s\\rDirectory {path.name} copied and formatted version created: {formatted_base_name}\",\n                ANSI_CODE[\"reset\"],\n            )\n        except FileExistsError:\n            LOGGER.info(\n                \"%s\\r\u26a0 The folder {formatted_path} already exists.\", ANSI_CODE[\"yellow\"]\n            )\n    return formatted_path\n</code></pre>"},{"location":"reference/utils/file_utils/#llmcode.utils.file_utils.ensure_folder_exist","title":"llmcode.utils.file_utils.ensure_folder_exist","text":"<pre><code>ensure_folder_exist(path)\n</code></pre> <p>Ensure that a folder path exists by creating any missing directories.</p> <p>This function takes a path as input, checks each segment of the path, and creates any directories that do not already exist. It supports both absolute and relative paths.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path of the directory to ensure exists.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the directory already existed, False if it was created.</p> Source code in <code>llmcode/utils/file_utils.py</code> <pre><code>def ensure_folder_exist(path):\n    \"\"\"\n    Ensure that a folder path exists by creating any missing directories.\n\n    This function takes a path as input, checks each segment of the path, and\n    creates any directories that do not already exist. It supports both absolute\n    and relative paths.\n\n    Args:\n        path (str): The path of the directory to ensure exists.\n\n    Returns:\n        (bool): True if the directory already existed, False if it was created.\n    \"\"\"\n    path = str(path)\n    separated = path.split(os.path.sep)\n    # To consider absolute paths\n    if separated[0] == \"\":\n        separated.pop(0)\n        separated[0] = os.path.sep + separated[0]\n    exists = True\n    for f in range(len(separated)):\n        path = (\n            os.path.sep.join(separated[: f + 1])\n            if f &gt; 0\n            else (separated[0] + os.path.sep)\n        )\n        if not os.path.exists(path):\n            os.mkdir(path)\n            exists = False\n    return exists\n</code></pre>"},{"location":"reference/utils/file_utils/#llmcode.utils.file_utils.get_temp_folder","title":"llmcode.utils.file_utils.get_temp_folder","text":"<pre><code>get_temp_folder()\n</code></pre> <p>Retrieves the path to the temporary folder based on the operating system.</p> <p>This function checks the platform on which Python is running and returns the appropriate path for the temporary folder. For Windows, it uses the TEMP environment variable. For Linux and macOS (Darwin), it returns the standard \"/tmp\" directory. If the operating system is not recognized, it raises an OSError.</p> <p>Returns:</p> Type Description <code>str</code> <p>The path to the temporary folder.</p> Source code in <code>llmcode/utils/file_utils.py</code> <pre><code>def get_temp_folder():\n    \"\"\"\n    Retrieves the path to the temporary folder based on the operating system.\n\n    This function checks the platform on which Python is running and returns the appropriate\n    path for the temporary folder. For Windows, it uses the TEMP environment variable. For\n    Linux and macOS (Darwin), it returns the standard \"/tmp\" directory. If the operating\n    system is not recognized, it raises an OSError.\n\n    Returns:\n        (str): The path to the temporary folder.\n    \"\"\"\n    system_platform = platform.system()\n    if system_platform == \"Windows\":\n        return os.environ[\"TEMP\"]\n    elif system_platform == \"Linux\" or system_platform == \"Darwin\":\n        return \"/tmp\"\n    else:\n        raise OSError(\"Unsupported operating system\")\n</code></pre>"},{"location":"reference/utils/logger/","title":"Reference for <code>llmcode/utils/logger.py</code>","text":"<p>This module configures logging for the application, ensuring compatibility across platforms.</p> <p>It sets up a logging configuration with platform-specific adjustments, such as filtering out emojis on Windows systems to prevent display issues.</p> <p>Functions:     set_logging: Configures the logging settings for the application.     emojis: Returns an emoji-safe version of a string based on the platform.</p> <p>Classes:     EmojiFilter: A custom logging filter class for removing emojis in log messages.</p> <p>Author: Francisco Javier Ga\u00f1\u00e1n License File: https://github.com/javierganan99/LLMCode/blob/main/LICENSE</p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/utils/logger/#llmcode.utils.logger.EmojiFilter","title":"llmcode.utils.logger.EmojiFilter","text":"<p>               Bases: <code>Filter</code></p> <p>A custom logging filter class for removing emojis in log messages.</p> <p>This filter is particularly useful for ensuring compatibility with Windows terminals that may not support the display of emojis in log messages.</p>"},{"location":"reference/utils/logger/#llmcode.utils.logger.EmojiFilter.filter","title":"filter","text":"<pre><code>filter(record)\n</code></pre> <p>Filter logs by emoji unicode characters on windows.</p> Source code in <code>llmcode/utils/logger.py</code> <pre><code>def filter(self, record):\n    \"\"\"Filter logs by emoji unicode characters on windows.\"\"\"\n    record.msg = emojis(record.msg)\n    return super().filter(record)\n</code></pre>"},{"location":"reference/utils/logger/#llmcode.utils.logger.set_logging","title":"llmcode.utils.logger.set_logging","text":"<pre><code>set_logging(name=LOGGING_NAME, verbose=True)\n</code></pre> Source code in <code>llmcode/utils/logger.py</code> <pre><code>def set_logging(name=LOGGING_NAME, verbose=True):\n    # TODO: Document this function on your own. Could not be documented by the model.\n    rank = int(os.getenv(\"RANK\", -1))  # rank in world for Multi-GPU\n    level = logging.INFO if verbose and rank in {-1, 0} else logging.ERROR\n    logging.config.dictConfig(\n        {\n            \"version\": 1,\n            \"disable_existing_loggers\": False,\n            \"formatters\": {name: {\"format\": \"%(message)s\"}},\n            \"handlers\": {\n                name: {\n                    \"class\": \"logging.StreamHandler\",\n                    \"formatter\": name,\n                    \"level\": level,\n                }\n            },\n            \"loggers\": {name: {\"level\": level, \"handlers\": [name], \"propagate\": False}},\n        }\n    )\n</code></pre>"},{"location":"reference/utils/logger/#llmcode.utils.logger.emojis","title":"llmcode.utils.logger.emojis","text":"<pre><code>emojis(string='')\n</code></pre> <p>Return platform-dependent emoji-safe version of string.</p> Source code in <code>llmcode/utils/logger.py</code> <pre><code>def emojis(string=\"\"):\n    \"\"\"Return platform-dependent emoji-safe version of string.\"\"\"\n    return string.encode().decode(\"ascii\", \"ignore\") if WINDOWS else string\n</code></pre>"}]}